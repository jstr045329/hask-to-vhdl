------------------------------------------------------------------------------------------------------------------------
--                                       Extract Information's Used As Inputs 
--
-- This module should not be confused with PortExtractor, which scrapes signals that are declared as inputs. This 
-- module, by contrast, figures out which names in a formula are inputs to that formula. 
--
-- The skeleton for this large if statement is generated by generateScrapeInputs.py. Modify that file if you add/remove
-- any rows to the if statement. 
--
-- Note that there are cases in this function where technically variables (or, even more remotely, signals) could 
-- be an input to whatever keyword or operator; yet in practice, that is exceedingly rare, and/or a bad idea.
-- We do not support those cases at this time. The reasons are twofold:
--
--      1) Variables are a low priority, and
--      2) Using a signal to inform an "after" statement seems like a really bad practice.
--
-- Also, we do not attempt to support cases where technically an input port, signal or variable could drive a 
-- statement, but in practice constants are (almost) always used. For instance:
--
--      signal mySignal : time; 
--      ...
--      mySignal <= 10 ns;
--      ...
--      wait for mySignal;
--
-- It is hard to imagine this being a good practice. Furthermore, a priori knowledge of which names are constants
-- (or not) is required in order to properly parse the "after" statement, "wait", etc. Therefore there is no point
-- in trying to deduce which names are signals as opposed to constants in this situation.
--
------------------------------------------------------------------------------------------------------------------------
module Parsing.ScrapeInputs (
    scrapeFormulaInputs
    ) where
import Parsing.PortExtractor
import Parsing.NumberRecognition
import Parsing.TokenMatchingTools
import Parsing.VhdlTokens
import Parsing.VhdlKeywords
import Tools.ListTools
import Parsing.VhdlTokensToRemove
import Parsing.ConstantRecognition
import Data.HashSet


------------------------------------------------------------------------------------------------------------------------
--                             Bite Off Tokens Before Closing Parenthesis, Remove Tokens 
------------------------------------------------------------------------------------------------------------------------
untilClosingParenRemoveTokens :: [String] -> [String]
untilClosingParenRemoveTokens los = [x | x <- (untilClosingParen (tail los) 0), not (isVhdlKeyword x), not (isVhdlToken x), not (isVhdlNumber x)]


------------------------------------------------------------------------------------------------------------------------
--                               Bite Off One Token To The Left, And One To The Right 
--
-- Useful for infix operators. TODO: Replace this with something that can look ahead through arbitrary nesting of 
-- parentheses and bite off until the next keyword or semicolon. 
--
------------------------------------------------------------------------------------------------------------------------
oneToTheLeftOneToTheRight :: [String] -> [String]
oneToTheLeftOneToTheRight los = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))


------------------------------------------------------------------------------------------------------------------------
--                                      Recur If List Of Strings Is Long Enough 
--
-- There is probably a way to eliminate this function. 
--
------------------------------------------------------------------------------------------------------------------------
recurIfMore :: [String] -> [String]
recurIfMore los
    | ((length los) < 2) = []
    | otherwise = scrapeFormulaInputsBrains (tail los)


------------------------------------------------------------------------------------------------------------------------
--                                            Reasons To Terminate Search 
--
-- If parser encounters one of these words, stop looking forward. 
--
------------------------------------------------------------------------------------------------------------------------
reasonsToTerminate :: HashSet String
reasonsToTerminate = fromList [
        "access"
    ,   "after"
    ,   "alias"
    ,   "all"
    ,   "architecture"
    ,   "array"
    ,   "assert"
    ,   "attribute"
    ,   "begin"
    ,   "block"
    ,   "body"
    ,   "buffer"
    ,   "bus"
    ,   "case"
    ,   "component"
    ,   "configuration"
    ,   "constant"
    ,   "disconnect"
    ,   "downto"
    ,   "end"
    ,   "entity"
    ,   "exit"
    ,   "file"
    ,   "for"
    ,   "function"
    ,   "generate"
    ,   "generic"
    ,   "group"
    ,   "guarded"
    ,   "impure"
    ,   "in"
    ,   "inertial"
    ,   "inout"
    ,   "is"
    ,   "label"
    ,   "library"
    ,   "linkage"
    ,   "literal"
    ,   "loop"
    ,   "map"
    ,   "new"
    ,   "next"
    ,   "null"
    ,   "of"
    ,   "on"
    ,   "open"
    ,   "others"
    ,   "out"
    ,   "package"
    ,   "port"
    ,   "postponed"
    ,   "procedure"
    ,   "pure"
    ,   "range"
    ,   "record"
    ,   "register"
    ,   "reject"
    ,   "return"
    ,   "select"
    ,   "severity"
    ,   "signal"
    ,   "shared"
    ,   "subtype"
    ,   "then"
    ,   "to"
    ,   "transport"
    ,   "type"
    ,   "unaffected"
    ,   "units"
    ,   "until"
    ,   "use"
    ,   "variable"
    ,   "wait"
    ,   "when"
    ,   "while"
    ,   "with"
    ,   ","
    ,   ":"
    ,   ";"
    ,   "=>"
    ]


------------------------------------------------------------------------------------------------------------------------
--                                              Reasons To Skip 1 Word 
--
-- If parser encounters one of these, skip that one word and continue searching. 
--
------------------------------------------------------------------------------------------------------------------------
reasonsToScrapeFormulaInputsBrainsTail1x :: HashSet String
reasonsToScrapeFormulaInputsBrainsTail1x = fromList [
        "("
    ,   ")"
    ,   "/="
    ,   "**"
    ,   "="
    ,   "<"
    ,   ">"
    ,   ">="
    ,   "("
    ,   ")"
    ,   "+"
    ,   "-"
    ,   "*"
    ,   "/"
    ,   "else"
    ,   "elsif"
    ,   "if"
    ,   "mod"
    ,   "not"
    ,   "process"
    ]


------------------------------------------------------------------------------------------------------------------------
--                                              Reasons To Skip 2 Words 
--
-- If parser encounters one of these, skip two words and continue searching. 
--
------------------------------------------------------------------------------------------------------------------------
reasonsToScrapeFormulaInputsBrainsTail2x :: HashSet String
reasonsToScrapeFormulaInputsBrainsTail2x = fromList [
        "rol"
    ,   "ror"
    ,   "sla"
    ,   "sli"
    ,   "sra"
    ,   "srl"
    ]


------------------------------------------------------------------------------------------------------------------------
--                                              Reasons To Skip 3 Words 
--
-- If parser encounters one of these, skip three words and continue searching. 
--
------------------------------------------------------------------------------------------------------------------------
reasonsToScrapeFormulaInputsBrainsTail3x :: HashSet String
reasonsToScrapeFormulaInputsBrainsTail3x = fromList [
        "and"
    ,   "nand"
    ,   "nor"
    ,   "or"
    ,   "xnor"
    ,   "xor"
    ]


------------------------------------------------------------------------------------------------------------------------
--                                     Reasons To Search for Closing Parentheses 
--
-- If parser encounters one of these, bite off enough tokens to reach the closing parenthesis, filter out VHDL reserved 
-- words, operators, and numbers, and return what's left. 
--
------------------------------------------------------------------------------------------------------------------------
reasonsToUntilClosingParenRemoveTokens :: HashSet String
reasonsToUntilClosingParenRemoveTokens = fromList [
        "abs"
    ,   "shift_left"
    ,   "shift_right"
    ,   "rotate_left"
    ,   "rotate_right"
    ,   "sll"
    ,   "srl"
    ,   "resize"
    ,   "to_integer"
    ,   "to_signed"
    ,   "to_unsigned"
    ,   "std_match"
    ,   "unsigned"
    ,   "signed"
    ]


------------------------------------------------------------------------------------------------------------------------
--                                  Reasons To Take The Left Token and Right Token 
------------------------------------------------------------------------------------------------------------------------
reasonsToOneToTheLeftOneToTheRight :: HashSet String
reasonsToOneToTheLeftOneToTheRight = fromList [
        "rem"
    ,   "mod"
    ]


------------------------------------------------------------------------------------------------------------------------
--                                        Low Precedence Reasons To Terminate 
--
-- If parser encounters any of these tokens, stop looking. The difference between this list and the reasons to terminate 
-- above is precedence. Membership in this list is checked AFTER several reasons to bite off several tokens have 
-- been considered. 
--
------------------------------------------------------------------------------------------------------------------------
lowPrecedenceReasonsToTerminate :: HashSet String
lowPrecedenceReasonsToTerminate = fromList [
        "<="
    ]


------------------------------------------------------------------------------------------------------------------------
--                             Scrape Tokens to The Right of Signal Assignment Operator 
------------------------------------------------------------------------------------------------------------------------
scrapeToTheRightOfSigAssignmentOperator :: [String] -> [String]
scrapeToTheRightOfSigAssignmentOperator los = [x | x <- (untilKeyword (afterKeyword los ["<="]) [";"] []), not (isVhdlKeyword x), not (isVhdlToken x), not (isVhdlNumber x)]


------------------------------------------------------------------------------------------------------------------------
--                            Scrape Tokens to The Right of Variable Assignment Operator 
------------------------------------------------------------------------------------------------------------------------
scrapeToTheRightOfVarAssignmentOperator :: [String] -> [String]
scrapeToTheRightOfVarAssignmentOperator los = [x | x <- (untilKeyword (afterKeyword los [":="]) [";"] []), not (isVhdlKeyword x), not (isVhdlToken x), not (isVhdlNumber x)]


------------------------------------------------------------------------------------------------------------------------
--                                                  Brain Function 
--
-- This helper function does the heavy lifting and the recursion. Don't call this though. Call the non-brain version 
-- at the bottom. 
--
-- NOTE: Input scraping from port maps not supported at this time.
-- There is simply no way to do it without a priori knowledge of port direction. 
--
------------------------------------------------------------------------------------------------------------------------
scrapeFormulaInputsBrains :: [String] -> [String]
scrapeFormulaInputsBrains [] = []
scrapeFormulaInputsBrains los
    | (elem (head los) reasonsToTerminate) = []

    -- TODO: Check if deleting this line breaks anything:
    | (((length los) > 3) && ((los !! 0) == "abs")) = stopAtClosingParen los 0 0
    | (((length los) > 1) && (elem (los !! 0) reasonsToUntilClosingParenRemoveTokens)) = untilClosingParenRemoveTokens los

    | ((length los == 1) && (elem (head los) lowPrecedenceReasonsToTerminate)) = []

    -- Check if (head los) is a signal assignment operator, and if so, deal with it appropriately:
    | ((head los == "<=") && ((indexOf ";" los 0) > 0) && ((indexOf "<=" los 0) > 0) && ((indexOf ";" los 0) > (indexOf "<=" los 0))) =
        []
        -- (scrapeToTheRightOfSigAssignmentOperator los) ++ (scrapeFormulaInputsBrains (afterKeyword los [";"]))

    -- Check if (head los) is a variable assignment operator, and if so, deal with it appropriately:
    | ((head los == ":=") && ((indexOf ";" los 0) > 0) && ((indexOf ":=" los 0) > 0) && ((indexOf ";" los 0) > (indexOf ":=" los 0))) =
        []
        -- (scrapeToTheRightOfVarAssignmentOperator los) ++ (scrapeFormulaInputsBrains (afterKeyword los [";"]))

    | (elem (head los) reasonsToScrapeFormulaInputsBrainsTail1x) = scrapeFormulaInputsBrains (tail' los)
    | (elem (head los) reasonsToScrapeFormulaInputsBrainsTail2x) = scrapeFormulaInputsBrains (tail' (tail' los))
    | (elem (head los) reasonsToScrapeFormulaInputsBrainsTail3x) = scrapeFormulaInputsBrains (tail' (tail' (tail' los)))
    | (elem (head los) reasonsToOneToTheLeftOneToTheRight) = oneToTheLeftOneToTheRight los
    | (elem (head los) lowPrecedenceReasonsToTerminate) = []
    | (isVhdlNumber (head los)) = scrapeFormulaInputsBrains (tail los)
    | otherwise = [head los] ++ (scrapeFormulaInputsBrains (tail los)) -- If a string made it this far, include it!


------------------------------------------------------------------------------------------------------------------------
--                                       The Function You Actually Want To Use 
--
-- This function is a handy wrapper for the monstrosity above. 
--
-- Filters out reserved words. We don't do that during the recursive part because that increases the order of the 
-- polynomial. 
--
-- The Brains version (above) will, in many places, only latch onto a keyword if the list of strings is longer than 
-- some minimum. In some places it's 1, but in some places it's higher. Anywho, we filter keywords out at the end 
-- in case some reserved word manages to sneak into the results. This is kinda like Bill & Hillary keeping Monica quiet,
-- but more effective.
-- 
------------------------------------------------------------------------------------------------------------------------
scrapeFormulaInputs :: [String] -> [String]
scrapeFormulaInputs los = [x | x <- (scrapeFormulaInputsBrains los), not (isTokenToRemove x), not (isVhdlNumber x), not (isVhdlToken x), not (isVhdlKeyword x), not (isConstant x)] 


