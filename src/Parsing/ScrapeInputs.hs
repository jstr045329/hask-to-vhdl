------------------------------------------------------------------------------------------------------------------------
--                                       Extract Information's Used As Inputs 
--
-- This module should not be confused with PortExtractor, which scrapes signals that are declared as inputs. This 
-- module, by contrast, figures out which names in a formula are inputs to that formula. 
--
-- The skeleton for this large if statement is generated by generateScrapeInputs.py. Modify that file if you add/remove
-- any rows to the if statement. 
--
-- Note that there are cases in this function where technically variables (or, even more remotely, signals) could 
-- be an input to whatever keyword or operator; yet in practice, that is exceedingly rare, and/or a bad idea.
-- We do not support those cases at this time. The reasons are twofold:
--
--      1) Variables are a low priority, and
--      2) Using a signal to inform an "after" statement seems like a really bad practice.
--
-- Also, we do not attempt to support cases where technically an input port, signal or variable could drive a 
-- statement, but in practice constants are (almost) always used. For instance:
--
--      signal mySignal : time; 
--      ...
--      mySignal <= 10 ns;
--      ...
--      wait for mySignal;
--
-- It is hard to imagine this being a good practice. Furthermore, a priori knowledge of which names are constants
-- (or not) is required in order to properly parse the "after" statement, "wait", etc. Therefore there is no point
-- in trying to deduce which names are signals as opposed to constants in this situation.
--
------------------------------------------------------------------------------------------------------------------------
module Parsing.ScrapeInputs where
import Parsing.PortExtractor
import Parsing.NumberRecognition

-- TODO: Go through every line, and figure out whether the (length los) > 1 condition needs to be removed.

recurIfMore :: [String] -> [String]
recurIfMore los
    | ((length los) < 2) = []
    | otherwise = scrapeFormulaInputs (tail los)


scrapeFormulaInputs :: [String] -> [String]
scrapeFormulaInputs [] = []
scrapeFormulaInputs los
    | ((length los) < 1) = []
    | ((head los) == "(") = scrapeFormulaInputs (tail los)
    | ((head los) == ")") = scrapeFormulaInputs (tail los)

    -- Skeleton from py script starts here:
    | (((length los) > 3) && ((los !! 0) == "abs")) = stopAtClosingParen los 0 0
    | ((los !! 0) == "access") = []
    | ((los !! 0) == "after") = [] -- Technically, an input could inform an "after" statement, but since that is nearly nonexistent we do not supportthat.
    | ((los !! 0) == "alias") = []
    | ((los !! 0) == "all") = []
    | (((length los) > 1) && ((los !! 1) == "and")) = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))
    | ((los !! 0) == "architecture") = []
    | ((los !! 0) == "array") = []
    | ((los !! 0) == "assert") = []
    | ((los !! 0) == "attribute") = []
    | ((los !! 0) == "begin") = []
    | ((los !! 0) == "block") = []
    | ((los !! 0) == "body") = []
    | ((los !! 0) == "buffer") = []
    | ((los !! 0) == "bus") = []
    | ((los !! 0) == "case") = [los!! 1]
    | ((los !! 0) == "component") = []
    | ((los !! 0) == "configuration") = []
    | ((los !! 0) == "constant") = []
    | ((los !! 0) == "disconnect") = []
    | ((los !! 0) == "downto") = [] -- Technically, an input could drive a downto, but we do not support that at this ime. 
    | (((length los) > 1) && ((los !! 0) == "else")) = scrapeFormulaInputs (tail los)
    | (((length los) > 1) && ((los !! 0) == "elsif")) = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "end") = []
    | ((los !! 0) == "entity") = []
    | ((los !! 0) == "exit") = []
    | ((los !! 0) == "file") = []
    | ((los !! 0) == "for") = []
    | ((los !! 0) == "function") = []
    | ((los !! 0) == "generate") = []
    | ((los !! 0) == "generic") = []
    | ((los !! 0) == "group") = []
    | ((los !! 0) == "guarded") = []
    | (((length los) > 1) && ((los !! 0) == "if")) = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "impure") = []
    | ((los !! 0) == "in") = []
    | ((los !! 0) == "inertial") = []
    | ((los !! 0) == "inout") = []
    | ((los !! 0) == "is") = []
    | ((los !! 0) == "label") = []
    | ((los !! 0) == "library") = []
    | ((los !! 0) == "linkage") = []
    | ((los !! 0) == "literal") = []
    | ((los !! 0) == "loop") = []
    | ((los !! 0) == "map") = []
    | (((length los) > 1) && ((los !! 0) == "mod")) = scrapeFormulaInputs (tail los)
    | (((length los) > 1) && ((los !! 0) == "nand")) = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))
    | ((los !! 0) == "new") = []
    | ((los !! 0) == "next") = []
    | (((length los) > 1) && ((los !! 0) == "nor")) = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))
    | (((length los) > 1) && ((los !! 0) == "not")) = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "null") = []
    | ((los !! 0) == "of") = []
    | ((los !! 0) == "on") = []
    | ((los !! 0) == "open") = []
    | (((length los) > 1) && ((los !! 0) == "or")) = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))
    | ((los !! 0) == "others") = []
    | ((los !! 0) == "out") = []
    | ((los !! 0) == "package") = []
    | ((los !! 0) == "port") = []
    | ((los !! 0) == "postponed") = []
    | ((los !! 0) == "procedure") = []
    | (((length los) > 1) && ((los !! 0) == "process")) = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "pure") = []
    | ((los !! 0) == "range") = []
    | ((los !! 0) == "record") = []
    | ((los !! 0) == "register") = []
    | ((los !! 0) == "reject") = []
    | ((los !! 0) == "return") = []
    | (((length los) > 1) && ((los !! 1) == "rol")) = [head los] ++ scrapeFormulaInputs (tail (tail los))
    | (((length los) > 1) && ((los !! 1) == "ror")) = [head los] ++ scrapeFormulaInputs (tail (tail los))
    | ((los !! 0) == "select") = []
    | ((los !! 0) == "severity") = []
    | ((los !! 0) == "signal") = []
    | ((los !! 0) == "shared") = []
    | (((length los) > 1) && ((los !! 1) == "sla")) = [head los] ++ scrapeFormulaInputs (tail (tail los))
    | (((length los) > 1) && ((los !! 1) == "sli")) = [head los] ++ scrapeFormulaInputs (tail (tail los))
    | (((length los) > 1) && ((los !! 1) == "sra")) = [head los] ++ scrapeFormulaInputs (tail (tail los))
    | (((length los) > 1) && ((los !! 1) == "srl")) = [head los] ++ scrapeFormulaInputs (tail (tail los))
    | ((los !! 0) == "subtype") = []
    | ((los !! 0) == "then") = []
    | ((los !! 0) == "to") = [] -- Technically an input could drive this, but that is not supported presently. 
    | ((los !! 0) == "transport") = []
    | ((los !! 0) == "type") = []
    | ((los !! 0) == "unaffected") = []
    | ((los !! 0) == "units") = []
    | ((los !! 0) == "until") = []
    | ((los !! 0) == "use") = []
    | ((los !! 0) == "variable") = []
    | ((los !! 0) == "wait") = []
    | ((los !! 0) == "when") = []
    | ((los !! 0) == "while") = []
    | ((los !! 0) == "with") = []
    | (((length los) > 1) && ((los !! 1) == "xnor")) = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))
    | (((length los) > 1) && ((los !! 1) == "xor")) = [los !! 0, los!! 2] ++ (recurIfMore (tail (tail (tail los))))

    -- Scrape Inputs From Infix Operators:
    | (((length los) > 2) && ((los !! 1) == "<=")) = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "<=") = recurIfMore los

    -- NOTE: Input scraping from port maps not supported at this time.
    -- There is simply no way to do it without a priori knowledge of port direction. 
    | ((los !! 0) == "=>") = [] 
    | ((los !! 0) == ":=") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "/=") = scrapeFormulaInputs (tail los)

    -- NOTE: Comments should be impossible after operator input is tokenized. 
    -- That is why this branch is commented out. 
    -- Besides, after line endings have been removed, there is simply no way to know
    -- when a comment ends. 
    --
    -- DO NOT delete this commented out line. It serves as a warning to those who,
    -- in a moment of weakness, might flirt with thoughts of transgression:
    -- | (((length los) > 1) && ((los !! 0) == "--")) = []

    | ((los !! 0) == "**") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "=") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "<") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == ">") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "(") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == ")") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "+") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "-") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "*") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == "/") = scrapeFormulaInputs (tail los)
    | ((los !! 0) == ",") = []
    | ((los !! 0) == ":") = []
    | ((los !! 0) == ";") = []

    -- TODO: Add common functions (to_signed, to_integer, etc.) to Py script, generate skeleton & flesh out. 

    | (isVhdlNumber (head los)) = scrapeFormulaInputs (tail los)

    -- If a string made it this far, include it!
    | otherwise = [head los] ++ scrapeFormulaInputs (tail los)

